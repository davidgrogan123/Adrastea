using Nightcap.Core.Diagnostics.CodeContract;

namespace Nightcap.Adrastea.Core.Events
{
    /// <summary>
    ///  Utility class for performing operations on a collection of 
    ///  EventHandlers.
    /// </summary>
    public sealed class EventUtil
    {
        #region static imlementation

        /// <summary>
        ///  Selects all the event handlers from <paramref name="eventHandlers"/>
        ///  that support event data of type <typeparamref name="T"/> and 
        ///  generates an event using <paramref name="eventArgs"/> as the 
        ///  event data.
        /// </summary>
        /// <param name="eventHandlers">
        ///  A collection of event handlers. May not be <c>null</c>.
        /// </param>
        /// <param name="sender">
        ///  The object that is generating the event. May not be <c>null</c>.
        /// </param>
        /// <param name="eventArgs">
        ///  The EventArgs to be used when raising the event. May not be 
        ///  <c>null</c>.
        /// </param>
        /// <typeparam name="T">
        ///  A type that inherits from EventArgs. 
        /// </typeparam>
        public static void GenerateEvent<T>(
              IEnumerable<Delegate> eventHandlers
            , object sender
            , T eventArgs
        ) where T : EventArgs
        {
            Requires.ThatArgumentIsNotNull(eventHandlers, "eventHandlers");
            Requires.ThatArgumentIsNotNull(sender, "sender");
            Requires.ThatArgumentIsNotNull(eventArgs, "eventArgs");

            (from d in eventHandlers
             where d is EventHandler<T>
             select d as EventHandler<T>)
                .ToList().ForEach(
                     e => e(sender, eventArgs)
                );
        }

        /// <summary>
        ///  Creates a collection of intermediate event handlers that support 
        ///  EventArgs of type <typeparamref name="T_IntermediateEventArgs"/>
        ///  which will generate all events in <paramref name="eventHandlers"/> 
        ///  that support EventArgs of type <typeparamref name="T_EventArgs"/>.
        /// </summary>
        /// <param name="eventHandlers">
        ///  A collection of handlers for events that may be generated. May 
        ///  not be <c>null</c>.
        /// </param>
        /// <param name="createIntermediateEventArgs">
        ///  A method to construct <typeparamref name="T_EventArgs"/> 
        ///  using <typeparamref name="T_IntermediateEventArgs"/>. May not be
        ///  <c>null</c>.
        /// </param>
        /// <typeparam name="T_EventArgs">
        ///  A type derived from <see cref="EventArgs"/> that may be supported 
        ///  by the event handlers in <paramref name="eventHandlers"/>
        ///  that is to be generated by the intermediate event handlers.
        /// </typeparam>
        /// <typeparam name="T_IntermediateEventArgs">
        ///  A type derived from <see cref="EventArgs"/> that is supported
        ///  by the intermediate event handlers.
        /// </typeparam>
        /// <returns>
        ///  A collection of intermediate event handlers with 
        ///  <see cref="EventArgs"/> of type 
        ///  <typeparamref name="T_IntermediateEventArgs"/>.
        /// </returns>
        public static IEnumerable<Delegate> CreateIntermediateEventHandlers
        <T_EventArgs, T_IntermediateEventArgs>(
              IEnumerable<Delegate> eventHandlers
            , Func<T_IntermediateEventArgs, T_EventArgs> createIntermediateEventArgs
        ) where T_EventArgs : EventArgs
          where T_IntermediateEventArgs : EventArgs
        {
            Requires.ThatArgumentIsNotNull(eventHandlers, "eventHandlers");
            Requires.ThatArgumentIsNotNull(createIntermediateEventArgs, "createIntermediateEventArgs");

            return (from d in eventHandlers
                    where d is EventHandler<T_EventArgs>
                    select d as EventHandler<T_EventArgs>)
                        .Select(e =>
                        {
                            EventHandler<T_IntermediateEventArgs> newEvent
                                = (sender, args) =>
                                {
                                    e(sender, createIntermediateEventArgs(args));
                                };
                            return newEvent as Delegate;
                        }
                        ).ToList().AsReadOnly();
        }
        #endregion
    }
}
